{
  "cacheItemsMap": {
    "articles/angular-firebase-hosting-gitlab.mdx": {
      "document": {
        "title": "Angular + Firebase Hosting + Gitlab",
        "publishedAt": "2020-10-17",
        "tags": [
          "angular",
          "firebase",
          "gitlab"
        ],
        "image": "/public/post-1-hero.webp",
        "body": {
          "raw": "\nSo in this guide, I'm going to show you how I deploy an angular site to Google's firebase hosting using Gitlabs CI/CD Pipelines to do all the build and deploy for me.\n\nI'm also going to be doing a staging / production builds, this way I can see things in staging and test/play and when i'm happy, push my changes to the repo's `main/master` branch and Gitlab will deploy it all to production.\n\nOk, so first thing, we need the Firebase CLI installed, using the following command in your terminal:\n\n```bash\nnpm install -g firebase-tools\n```\n\nOnce that is all done, head over to the [Firebase Console](https://console.firebase.google.com/) and create 2 new projects:\n\nFor this demo, I created 2\n\n`fir-hosting-demo-staging`\nand\n`fir-hosting-demo-prod`\n\nYou need to have 2 seperate projects if you want to deploy to staging and then production, if you don't, just create the one project.\n\nOnce they're created, head back over to your Angular application, we've got a bit of preparation to do.\n\nNavigate to your angular application using a terminal and run the following command:\n\n`firebase init`\n\nHighlight the `hosting` option and then the `Use an existing project` option.\n\nSelect your _Staging_ project from the list that you get by using the arrow keys.\n\nYou'll then be asked the question\n\n```bash\nWhat do you want to use as your public directory?\n```\n\nThis is the path that is set in the `angular.json` for `outputPath`, it's the path that everything goes to when you run `ng build`.\n\nFor me, it is `dist/firebase-hosting-demo` as that is the name of my Angular application. So set it to that.\n\nYou'll then be asked about redirects and as its an angular application, you'll want to select `yes` to redirect everything to `index.html`.\n\nOnce you have ran this command, open up the newly created file called `.firebaserc` and it should look something like this:\n\n```\n{\n  \"projects\": {\n    \"default\": \"fir-hosting-demo-staging\"\n  }\n}\n```\n\nI like to rename my project alias, so go ahead and change `default` to `staging`\n\n```\n{\n  \"projects\": {\n    \"staging\": \"fir-hosting-demo-staging\"\n  }\n}\n```\n\nWe're now going to add our production hosting, run the following command in the terminal.\n\n`firebase use --add`\n\nYou'll then be given a list of your current firebase projects, select the production one you created.\n\nYou then have to give it an alias, I like to call mine `production`.\n\nIf you head over to the `.firebaserc` file, it should now look like this:\n\n```\n{\n  \"projects\": {\n    \"staging\": \"fir-hosting-demo-staging\",\n    \"production\": \"fir-hosting-demo-prod\"\n  }\n}\n```\n\nYou can now in the terminal of that project, just run\n\n`firebase use staging` and it will switch to use the staging project, same for `firebase use production`.\n\nNow, if everything has been setup right, you can go ahead and do a test build/deploy.\n\nIn your terminal, make sure you're using `staging` by running\n`firebase use staging`\n\nBuild your Angular application using the command\n`ng build`\n\nOnce that has built, you should have a `dist` folder with your application inside, for me it's `dist/firebase-hosting-demo`.\n\nGo ahead and run the command `firebase deploy --only hosting` and watch as Firebase will now take all the built files from the output folder and upload them to firebase staging branch.\n\nOnce that has completed, the firebase cli will return a Hosting URL where you can see you staging application.\n\nYou can do the same for the production branch buy running the command to switch to production `firebase use production` and then the same `firebase deploy --only hosting` and the same files will be pushed to the production project in firebase.\n\nThis is good for testing, but it will become a bit tedious to remember which branch you're on, which project you're using and remembering that you need to build/push your code.\n\nThis is where we're going to leverage Gitlab and let it do all of the work for you.\n\nOther CI/CD tools can do the same, I just mainly use Gitlab.\n\nSo now this is all setup, let's move onto the next step!\n\n# Gitlab\n\nIf you have your code all stored in Gitlab, the way I like to work is have 3 branches, `master`, `staging`, and `develop`.\n\nBoth `master` and `staging` are protected branches and cannot be pushed to locally, only via a merge request using Gitlab.\n\nSo, for me, I'm going to switch to the `develop` branch of my code.\n\n`git checkout -b develop`\n\nWe're going to need a CI Token, this is a firebase token that Gitlab can use to act on our behalf. To get one of these, in your terminal, run the command\n\n```\nfirebase login:ci\n```\n\nA popup will appear in your browser to login and ask for permissions, once you have done that, back in your terminal, you'll be given a CI Token that looks a bit like this.\n\n```\n1//03s000000000000000000000F-L9I00000000000000W-_000000Tg\n```\n\nI have purposely changed mine for this demo, yours won't have lots of zeros inside it.\n\nHead over to gitlab as we now need to store this token in the project.\n\nIn your repo in gitlab, click the _Settings > CI/CD_ and expand the section for _Variables_.\n\nClick the `Add Variable` button and a window like this will appear.\n\n![Gitlab Variables](https://dev-to-uploads.s3.amazonaws.com/i/8x3upg8rocxa8opcu1f5.png)\n\nCall the variable `FIREBASE_TOKEN`, and paste in the value you got from the `ci:login` before. I don't have the variable protected or masked, I have found that sometimes Gitlab has issues when I check these options.\n\nSave the variable and we're done with this part of the setup.\n\nBack into our code, create a new file at the `ROOT` level of your project called `.gitlab-ci.yml`. This is a file that gives Gitlab the instructions needed to build your project.\n\nPaste in the following into that file:\n\n```\nstages:\n    - build\n    - deploy\n\nimage: node:12.13.0-alpine\n\ncache:\n    paths:\n        - node_modules/\n\nbuild-staging:\n    stage: build\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"staging\"\n    script:\n        # Install dependencies\n        - npm install\n        # Build App\n        - npm run build\n    artifacts:\n        paths:\n            # Build folder\n            - dist/firebase-hosting-demo\n        expire_in: 1 hour\n\ndeploy-staging:\n    stage: deploy\n    script:\n        - npm install -g firebase-tools\n        - firebase use --token $FIREBASE_TOKEN staging\n        - firebase deploy --only hosting -m \"Pipeline $CI_PIPELINE_ID, build $CI_BUILD_ID\" --non-interactive --token $FIREBASE_TOKEN\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"staging\"\n\nbuild-production:\n    stage: build\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"master\"\n    script:\n        # Install dependencies\n        - npm install\n        # Build App\n        - npm run build\n    artifacts:\n        paths:\n            # Build folder\n            - dist/firebase-hosting-demo\n        expire_in: 1 hour\n\ndeploy-production:\n    stage: deploy\n    script:\n        - npm install -g firebase-tools\n        - firebase use --token $FIREBASE_TOKEN production\n        - firebase deploy --only hosting -m \"Pipeline $CI_PIPELINE_ID, build $CI_BUILD_ID\" --non-interactive --token $FIREBASE_TOKEN\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"master\"\n\n```\n\nI'm not going to go over in depth what this file does, but essentially, it will build and deploy your Angular application for you, but use different Firebase projects depending on what Git branch you use.\n\nSo the idea is, make some code changes on your `develop` branch. Once you're happy, commit and push your code to the remote develop branch.\n\nDo a merge request when you're ready from `develop` to `staging` and watch as Gitlab will start a pipeline to build your Angular app and deploy it to Firebase.\n\nWhen you're happy to go live, do another merge request from `staging` to `master` in Gitlab and it will build again and deploy to production.\n\nThe first time this runs it might take some time, this is because in my `gitlab-ci.yml` file, I have specified to cache the `node_modules`, but once this has done, pipelines that run after this should be faster!\n\nHope you enjoyed my guide, and any questions, don't hesitate to contact me!.\n",
          "html": "<p>So in this guide, I'm going to show you how I deploy an angular site to Google's firebase hosting using Gitlabs CI/CD Pipelines to do all the build and deploy for me.</p>\n<p>I'm also going to be doing a staging / production builds, this way I can see things in staging and test/play and when i'm happy, push my changes to the repo's <code>main/master</code> branch and Gitlab will deploy it all to production.</p>\n<p>Ok, so first thing, we need the Firebase CLI installed, using the following command in your terminal:</p>\n<pre><code class=\"language-bash\">npm install -g firebase-tools\n</code></pre>\n<p>Once that is all done, head over to the <a href=\"https://console.firebase.google.com/\">Firebase Console</a> and create 2 new projects:</p>\n<p>For this demo, I created 2</p>\n<p><code>fir-hosting-demo-staging</code>\nand\n<code>fir-hosting-demo-prod</code></p>\n<p>You need to have 2 seperate projects if you want to deploy to staging and then production, if you don't, just create the one project.</p>\n<p>Once they're created, head back over to your Angular application, we've got a bit of preparation to do.</p>\n<p>Navigate to your angular application using a terminal and run the following command:</p>\n<p><code>firebase init</code></p>\n<p>Highlight the <code>hosting</code> option and then the <code>Use an existing project</code> option.</p>\n<p>Select your <em>Staging</em> project from the list that you get by using the arrow keys.</p>\n<p>You'll then be asked the question</p>\n<pre><code class=\"language-bash\">What do you want to use as your public directory?\n</code></pre>\n<p>This is the path that is set in the <code>angular.json</code> for <code>outputPath</code>, it's the path that everything goes to when you run <code>ng build</code>.</p>\n<p>For me, it is <code>dist/firebase-hosting-demo</code> as that is the name of my Angular application. So set it to that.</p>\n<p>You'll then be asked about redirects and as its an angular application, you'll want to select <code>yes</code> to redirect everything to <code>index.html</code>.</p>\n<p>Once you have ran this command, open up the newly created file called <code>.firebaserc</code> and it should look something like this:</p>\n<pre><code>{\n  \"projects\": {\n    \"default\": \"fir-hosting-demo-staging\"\n  }\n}\n</code></pre>\n<p>I like to rename my project alias, so go ahead and change <code>default</code> to <code>staging</code></p>\n<pre><code>{\n  \"projects\": {\n    \"staging\": \"fir-hosting-demo-staging\"\n  }\n}\n</code></pre>\n<p>We're now going to add our production hosting, run the following command in the terminal.</p>\n<p><code>firebase use --add</code></p>\n<p>You'll then be given a list of your current firebase projects, select the production one you created.</p>\n<p>You then have to give it an alias, I like to call mine <code>production</code>.</p>\n<p>If you head over to the <code>.firebaserc</code> file, it should now look like this:</p>\n<pre><code>{\n  \"projects\": {\n    \"staging\": \"fir-hosting-demo-staging\",\n    \"production\": \"fir-hosting-demo-prod\"\n  }\n}\n</code></pre>\n<p>You can now in the terminal of that project, just run</p>\n<p><code>firebase use staging</code> and it will switch to use the staging project, same for <code>firebase use production</code>.</p>\n<p>Now, if everything has been setup right, you can go ahead and do a test build/deploy.</p>\n<p>In your terminal, make sure you're using <code>staging</code> by running\n<code>firebase use staging</code></p>\n<p>Build your Angular application using the command\n<code>ng build</code></p>\n<p>Once that has built, you should have a <code>dist</code> folder with your application inside, for me it's <code>dist/firebase-hosting-demo</code>.</p>\n<p>Go ahead and run the command <code>firebase deploy --only hosting</code> and watch as Firebase will now take all the built files from the output folder and upload them to firebase staging branch.</p>\n<p>Once that has completed, the firebase cli will return a Hosting URL where you can see you staging application.</p>\n<p>You can do the same for the production branch buy running the command to switch to production <code>firebase use production</code> and then the same <code>firebase deploy --only hosting</code> and the same files will be pushed to the production project in firebase.</p>\n<p>This is good for testing, but it will become a bit tedious to remember which branch you're on, which project you're using and remembering that you need to build/push your code.</p>\n<p>This is where we're going to leverage Gitlab and let it do all of the work for you.</p>\n<p>Other CI/CD tools can do the same, I just mainly use Gitlab.</p>\n<p>So now this is all setup, let's move onto the next step!</p>\n<h1>Gitlab</h1>\n<p>If you have your code all stored in Gitlab, the way I like to work is have 3 branches, <code>master</code>, <code>staging</code>, and <code>develop</code>.</p>\n<p>Both <code>master</code> and <code>staging</code> are protected branches and cannot be pushed to locally, only via a merge request using Gitlab.</p>\n<p>So, for me, I'm going to switch to the <code>develop</code> branch of my code.</p>\n<p><code>git checkout -b develop</code></p>\n<p>We're going to need a CI Token, this is a firebase token that Gitlab can use to act on our behalf. To get one of these, in your terminal, run the command</p>\n<pre><code>firebase login:ci\n</code></pre>\n<p>A popup will appear in your browser to login and ask for permissions, once you have done that, back in your terminal, you'll be given a CI Token that looks a bit like this.</p>\n<pre><code>1//03s000000000000000000000F-L9I00000000000000W-_000000Tg\n</code></pre>\n<p>I have purposely changed mine for this demo, yours won't have lots of zeros inside it.</p>\n<p>Head over to gitlab as we now need to store this token in the project.</p>\n<p>In your repo in gitlab, click the <em>Settings > CI/CD</em> and expand the section for <em>Variables</em>.</p>\n<p>Click the <code>Add Variable</code> button and a window like this will appear.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/8x3upg8rocxa8opcu1f5.png\" alt=\"Gitlab Variables\"></p>\n<p>Call the variable <code>FIREBASE_TOKEN</code>, and paste in the value you got from the <code>ci:login</code> before. I don't have the variable protected or masked, I have found that sometimes Gitlab has issues when I check these options.</p>\n<p>Save the variable and we're done with this part of the setup.</p>\n<p>Back into our code, create a new file at the <code>ROOT</code> level of your project called <code>.gitlab-ci.yml</code>. This is a file that gives Gitlab the instructions needed to build your project.</p>\n<p>Paste in the following into that file:</p>\n<pre><code>stages:\n    - build\n    - deploy\n\nimage: node:12.13.0-alpine\n\ncache:\n    paths:\n        - node_modules/\n\nbuild-staging:\n    stage: build\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"staging\"\n    script:\n        # Install dependencies\n        - npm install\n        # Build App\n        - npm run build\n    artifacts:\n        paths:\n            # Build folder\n            - dist/firebase-hosting-demo\n        expire_in: 1 hour\n\ndeploy-staging:\n    stage: deploy\n    script:\n        - npm install -g firebase-tools\n        - firebase use --token $FIREBASE_TOKEN staging\n        - firebase deploy --only hosting -m \"Pipeline $CI_PIPELINE_ID, build $CI_BUILD_ID\" --non-interactive --token $FIREBASE_TOKEN\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"staging\"\n\nbuild-production:\n    stage: build\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"master\"\n    script:\n        # Install dependencies\n        - npm install\n        # Build App\n        - npm run build\n    artifacts:\n        paths:\n            # Build folder\n            - dist/firebase-hosting-demo\n        expire_in: 1 hour\n\ndeploy-production:\n    stage: deploy\n    script:\n        - npm install -g firebase-tools\n        - firebase use --token $FIREBASE_TOKEN production\n        - firebase deploy --only hosting -m \"Pipeline $CI_PIPELINE_ID, build $CI_BUILD_ID\" --non-interactive --token $FIREBASE_TOKEN\n    rules:\n        - if: $CI_COMMIT_BRANCH == \"master\"\n\n</code></pre>\n<p>I'm not going to go over in depth what this file does, but essentially, it will build and deploy your Angular application for you, but use different Firebase projects depending on what Git branch you use.</p>\n<p>So the idea is, make some code changes on your <code>develop</code> branch. Once you're happy, commit and push your code to the remote develop branch.</p>\n<p>Do a merge request when you're ready from <code>develop</code> to <code>staging</code> and watch as Gitlab will start a pipeline to build your Angular app and deploy it to Firebase.</p>\n<p>When you're happy to go live, do another merge request from <code>staging</code> to <code>master</code> in Gitlab and it will build again and deploy to production.</p>\n<p>The first time this runs it might take some time, this is because in my <code>gitlab-ci.yml</code> file, I have specified to cache the <code>node_modules</code>, but once this has done, pipelines that run after this should be faster!</p>\n<p>Hope you enjoyed my guide, and any questions, don't hesitate to contact me!.</p>"
        },
        "_id": "articles/angular-firebase-hosting-gitlab.mdx",
        "_raw": {
          "sourceFilePath": "articles/angular-firebase-hosting-gitlab.mdx",
          "sourceFileName": "angular-firebase-hosting-gitlab.mdx",
          "sourceFileDir": "articles",
          "contentType": "mdx",
          "flattenedPath": "articles/angular-firebase-hosting-gitlab"
        },
        "type": "Article",
        "readingTime": {
          "text": "7 min read",
          "minutes": 6.305,
          "time": 378300,
          "words": 1261
        },
        "wordCount": 1263,
        "slug": "angular-firebase-hosting-gitlab"
      },
      "documentHash": "1673616950031",
      "hasWarnings": false,
      "documentTypeName": "Article"
    },
    "articles/angular-tailwind-css-guide.mdx": {
      "document": {
        "title": "Angular 8/9/10 + Tailwind CSS Guide",
        "publishedAt": "2019-11-12",
        "tags": [
          "angular",
          "tailwindcss"
        ],
        "image": "/public/post-1-hero.webp",
        "body": {
          "raw": "\nSo, I've found a lot of crappy guides on the internet about how to integrate TailwindCSS with Angular 8, a lot of them involve some nasty hacks that I think are basically, shit. I've collated some information from various sources online to show you how I go about implementing TailwindCSS with Angular 8. If you're reading this and you don't know what TailwindCSS is, two things, one, where the hell have you been the past few years and two, go to tailwindcss.com and feast in the amazingness (is that even a word) that is Tailwind.\n\nWe'll be utilising the @angular-builders/custom-webpack package which will essentially allow us to tailor the webpack build to add tailwind into the build process.\n\nFirst things first, install the following:\n\n`npm i tailwindcss postcss-scss postcss-import postcss-loader @angular-builders/custom-webpack -D\n`\n\nNext you need to open up your Angular project, I'm going to assume you're using sass, as well, why the fuck not?\n\nOpen your `styles.scss` file and add the following at the top.\n\n```\n@import 'tailwindcss/base';\n@import 'tailwindcss/components';\n@import 'tailwindcss/utilities';\n```\n\nNext, you need to create the tailwind config file, to do so, open your terminal and smash in the following (inside the directory of your app of course).\n\n`npx tailwind init`\n\nNow we need to extend the webpack config, first, start by creating `webpack.config.js` at the root of your project, this is what it should look like\n\n```\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.scss$/,\n                loader: 'postcss-loader',\n                options: {\n                    ident: 'postcss',\n                    syntax: 'postcss-scss',\n                    plugins: () => [\n                        require('postcss-import'),\n                        require('tailwindcss'),\n                        require('autoprefixer'),\n                    ]\n                }\n            }\n        ]\n    }\n};\n```\n\nOnce you've added that, modify the `angular.json` file to tell it to use the custom builder and config file.\n\n```\n{\n  \"architect\": {\n    \"build\": {\n      \"builder\": \"@angular-builders/custom-webpack:browser\",\n      \"options\": {\n        \"customWebpackConfig\": {\n          \"path\": \"./webpack.config.js\"\n        }\n      }\n    },\n    \"serve\": {\n      \"builder\": \"@angular-builders/custom-webpack:dev-server\",\n      \"options\": {\n        \"customWebpackConfig\": {\n          \"path\": \"./webpack.config.js\"\n        }\n      }\n    }\n  }\n}\n```\n\nNow we're all up and ready to rumble, add some tailwind classes to an object and run\n\n`npm start`\n\n_Extra_\n\nThe whole point of Tailwind is to create custom utilities, you can do so by doing the following:\n\nModify your `styles.scss` and add 2 new custom imports.\n\n```\n@import 'tailwindcss/base';\n@import 'tailwindcss/components';\n@import './custom-tailwind/custom-components.css'; // added\n@import 'tailwindcss/utilities';\n@import './custom-tailwind/custom-utilities.css'; // added\n```\n\nMake sure that they're added in the exact order above.\n\nYou can now create a folder inside the src directory called `custom-tailwind`\nInside this, you create the 2 files the same names as above, now you can create custom reusable utilities and components, for example:\n\n`custom-components.css`\n\n```\n.btn {\n  @apply px-4;\n  @apply py-2;\n  @apply rounded;\n  @apply bg-indigo-500;\n  @apply text-white;\n  transition: 200ms;\n}\n\n.btn:hover {\n  @apply bg-indigo-600;\n}\n```\n\nAnd now anywhere you want a button, just give it the class `.btn` and it will apply all the tailwind classes.\n\nFor `custom-utilities.css`, you can do the following:\n\n```\n.rotate-0 {\n    transform: rotate(0deg);\n}\n.rotate-90 {\n    transform: rotate(90deg);\n}\n.rotate-180 {\n    transform: rotate(180deg);\n}\n.rotate-270 {\n    transform: rotate(270deg);\n}\n```\n\nAnd now anywhere, you can just call these classes. Neat huh!\n\nEnjoy the power that is TailwindCSS + Angular 8!\n\n**Update:**\n\nI realise this is a repeated post, for some reason I had 3 dev.to accounts (god knows why) and this is the account I wanted to use, so I deleted this post along with the other account and re-created it here.\n\n**Update 2:**\n\nThis also works the same way with Angular 9, I have this working using angular version `\"@angular/core\": \"~9.0.0\",`\n\n**Update 3: Angular 10.X**\n\npostcss-loader came with some _breaking changes_ when it jumped from version 3 to 4.\n\nI managed to get Angular 10 and Tailwind to play nicely by changing my `webpack.config.js` to the following:\n\n```\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/,\n        loader: 'postcss-loader',\n        options: {\n-          ident: 'postcss',\n-          syntax: 'postcss-scss',\n-          plugins: () => [\n-            require('postcss-import'),\n-            require('tailwindcss'),\n-            require('autoprefixer'),\n-          ],\n+          postcssOptions: {\n+           ident: 'postcss',\n+            syntax: 'postcss-scss',\n+            plugins: [\n+              require('postcss-import'),\n+              require('tailwindcss'),\n+              require('autoprefixer'),\n            ],\n          },\n        },\n      },\n    ],\n  },\n};\n```\n\nThanks to [@phileagleson](https://github.com/notiz-dev/notiz/issues/111#issuecomment-689249664) for spotting this!\n\nYou can also skip the entire above process and just the the **Schematic** that was created to do the work for you.\n\n[garygrossgarten/ngx-tailwind](https://github.com/garygrossgarten/ngx-tailwind)\n\nNote, you will still need to change the `webpack.config.js` even if you use the Schematic when using this with `postcss-loader` Version 4 and Angular 10\n\n## Update\n\nThanks to [thieugiatri4492](https://dev.to/thieugiatri4492) for pointing out that if you used my manual method of installing Tailwind, and then moved over to use the schematic, you'll need to remove the webpack.config.js before using the schematic otherwise it will throw an error that it already exists!\n",
          "html": "<p>So, I've found a lot of crappy guides on the internet about how to integrate TailwindCSS with Angular 8, a lot of them involve some nasty hacks that I think are basically, shit. I've collated some information from various sources online to show you how I go about implementing TailwindCSS with Angular 8. If you're reading this and you don't know what TailwindCSS is, two things, one, where the hell have you been the past few years and two, go to tailwindcss.com and feast in the amazingness (is that even a word) that is Tailwind.</p>\n<p>We'll be utilising the @angular-builders/custom-webpack package which will essentially allow us to tailor the webpack build to add tailwind into the build process.</p>\n<p>First things first, install the following:</p>\n<p><code>npm i tailwindcss postcss-scss postcss-import postcss-loader @angular-builders/custom-webpack -D </code></p>\n<p>Next you need to open up your Angular project, I'm going to assume you're using sass, as well, why the fuck not?</p>\n<p>Open your <code>styles.scss</code> file and add the following at the top.</p>\n<pre><code>@import 'tailwindcss/base';\n@import 'tailwindcss/components';\n@import 'tailwindcss/utilities';\n</code></pre>\n<p>Next, you need to create the tailwind config file, to do so, open your terminal and smash in the following (inside the directory of your app of course).</p>\n<p><code>npx tailwind init</code></p>\n<p>Now we need to extend the webpack config, first, start by creating <code>webpack.config.js</code> at the root of your project, this is what it should look like</p>\n<pre><code>module.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.scss$/,\n                loader: 'postcss-loader',\n                options: {\n                    ident: 'postcss',\n                    syntax: 'postcss-scss',\n                    plugins: () => [\n                        require('postcss-import'),\n                        require('tailwindcss'),\n                        require('autoprefixer'),\n                    ]\n                }\n            }\n        ]\n    }\n};\n</code></pre>\n<p>Once you've added that, modify the <code>angular.json</code> file to tell it to use the custom builder and config file.</p>\n<pre><code>{\n  \"architect\": {\n    \"build\": {\n      \"builder\": \"@angular-builders/custom-webpack:browser\",\n      \"options\": {\n        \"customWebpackConfig\": {\n          \"path\": \"./webpack.config.js\"\n        }\n      }\n    },\n    \"serve\": {\n      \"builder\": \"@angular-builders/custom-webpack:dev-server\",\n      \"options\": {\n        \"customWebpackConfig\": {\n          \"path\": \"./webpack.config.js\"\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Now we're all up and ready to rumble, add some tailwind classes to an object and run</p>\n<p><code>npm start</code></p>\n<p><em>Extra</em></p>\n<p>The whole point of Tailwind is to create custom utilities, you can do so by doing the following:</p>\n<p>Modify your <code>styles.scss</code> and add 2 new custom imports.</p>\n<pre><code>@import 'tailwindcss/base';\n@import 'tailwindcss/components';\n@import './custom-tailwind/custom-components.css'; // added\n@import 'tailwindcss/utilities';\n@import './custom-tailwind/custom-utilities.css'; // added\n</code></pre>\n<p>Make sure that they're added in the exact order above.</p>\n<p>You can now create a folder inside the src directory called <code>custom-tailwind</code>\nInside this, you create the 2 files the same names as above, now you can create custom reusable utilities and components, for example:</p>\n<p><code>custom-components.css</code></p>\n<pre><code>.btn {\n  @apply px-4;\n  @apply py-2;\n  @apply rounded;\n  @apply bg-indigo-500;\n  @apply text-white;\n  transition: 200ms;\n}\n\n.btn:hover {\n  @apply bg-indigo-600;\n}\n</code></pre>\n<p>And now anywhere you want a button, just give it the class <code>.btn</code> and it will apply all the tailwind classes.</p>\n<p>For <code>custom-utilities.css</code>, you can do the following:</p>\n<pre><code>.rotate-0 {\n    transform: rotate(0deg);\n}\n.rotate-90 {\n    transform: rotate(90deg);\n}\n.rotate-180 {\n    transform: rotate(180deg);\n}\n.rotate-270 {\n    transform: rotate(270deg);\n}\n</code></pre>\n<p>And now anywhere, you can just call these classes. Neat huh!</p>\n<p>Enjoy the power that is TailwindCSS + Angular 8!</p>\n<p><strong>Update:</strong></p>\n<p>I realise this is a repeated post, for some reason I had 3 dev.to accounts (god knows why) and this is the account I wanted to use, so I deleted this post along with the other account and re-created it here.</p>\n<p><strong>Update 2:</strong></p>\n<p>This also works the same way with Angular 9, I have this working using angular version <code>\"@angular/core\": \"~9.0.0\",</code></p>\n<p><strong>Update 3: Angular 10.X</strong></p>\n<p>postcss-loader came with some <em>breaking changes</em> when it jumped from version 3 to 4.</p>\n<p>I managed to get Angular 10 and Tailwind to play nicely by changing my <code>webpack.config.js</code> to the following:</p>\n<pre><code>module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.scss$/,\n        loader: 'postcss-loader',\n        options: {\n-          ident: 'postcss',\n-          syntax: 'postcss-scss',\n-          plugins: () => [\n-            require('postcss-import'),\n-            require('tailwindcss'),\n-            require('autoprefixer'),\n-          ],\n+          postcssOptions: {\n+           ident: 'postcss',\n+            syntax: 'postcss-scss',\n+            plugins: [\n+              require('postcss-import'),\n+              require('tailwindcss'),\n+              require('autoprefixer'),\n            ],\n          },\n        },\n      },\n    ],\n  },\n};\n</code></pre>\n<p>Thanks to <a href=\"https://github.com/notiz-dev/notiz/issues/111#issuecomment-689249664\">@phileagleson</a> for spotting this!</p>\n<p>You can also skip the entire above process and just the the <strong>Schematic</strong> that was created to do the work for you.</p>\n<p><a href=\"https://github.com/garygrossgarten/ngx-tailwind\">garygrossgarten/ngx-tailwind</a></p>\n<p>Note, you will still need to change the <code>webpack.config.js</code> even if you use the Schematic when using this with <code>postcss-loader</code> Version 4 and Angular 10</p>\n<h2>Update</h2>\n<p>Thanks to <a href=\"https://dev.to/thieugiatri4492\">thieugiatri4492</a> for pointing out that if you used my manual method of installing Tailwind, and then moved over to use the schematic, you'll need to remove the webpack.config.js before using the schematic otherwise it will throw an error that it already exists!</p>"
        },
        "_id": "articles/angular-tailwind-css-guide.mdx",
        "_raw": {
          "sourceFilePath": "articles/angular-tailwind-css-guide.mdx",
          "sourceFileName": "angular-tailwind-css-guide.mdx",
          "sourceFileDir": "articles",
          "contentType": "mdx",
          "flattenedPath": "articles/angular-tailwind-css-guide"
        },
        "type": "Article",
        "readingTime": {
          "text": "4 min read",
          "minutes": 3.835,
          "time": 230100,
          "words": 767
        },
        "wordCount": 777,
        "slug": "angular-tailwind-css-guide"
      },
      "documentHash": "1673617136105",
      "hasWarnings": false,
      "documentTypeName": "Article"
    },
    "articles/dayjs-with-relative-time-nuxtjs.mdx": {
      "document": {
        "title": "Day.js with RelativeTime in Nuxt.js",
        "publishedAt": "2022-02-23",
        "tags": [
          "dayjs",
          "nuxtjs",
          "vue"
        ],
        "image": "/public/post-1-hero.webp",
        "body": {
          "raw": "\nLigula sit amet elementum mollis, neque odio eleifend lacus, non laoreet arcu risus id nibh. Cras vel nulla id arcu ullamcorper sodales sed sit amet lorem. Praesent pharetra, lectus eget rutrum cursus, orci metus cursus erat, a rhoncus ex velit ut purus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Ut in ipsum hendrerit, bibendum nibh ac, bibendum metus. Aenean volutpat est lectus, scelerisque congue risus fermentum ut. Pellentesque rutrum tempor ex, et accumsan enim. Maecenas a sem luctus, placerat diam eget, tempus quam. Fusce congue quam at vehicula efficitur. Vivamus gravida felis non nunc vulputate, laoreet aliquam sapien venenatis. Aenean viverra sapien ut orci lacinia vestibulum. Mauris at gravida tortor, non eleifend libero. In ut ipsum lacus. Proin risus velit, ornare et pulvinar at, sodales eget quam. Donec interdum in nulla nec dapibus.\n\nCurabitur scelerisque blandit placerat. Duis consequat tincidunt tortor, nec euismod ante ultrices et. Ut imperdiet, metus et fermentum blandit, mi elit scelerisque nunc, id porttitor justo ligula in lorem. Ut et ipsum tellus. Sed feugiat dolor sed accumsan bibendum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris lorem purus, mollis ut lobortis at, sodales ac justo.\n\nDuis turpis eros, lobortis eu feugiat a, mattis dapibus diam. Nulla at quam eros. Pellentesque consectetur varius tellus non sagittis. Aliquam erat volutpat. Pellentesque sed ante ac velit tempus hendrerit. Fusce sit amet eros a turpis dictum pharetra. Duis vulputate ultricies orci, nec pharetra dui dictum non. Proin convallis, justo vel malesuada molestie, mauris orci tincidunt diam, ultrices volutpat mi orci in augue. Nullam lorem erat, cursus a pellentesque nec, porta sit amet tellus. Donec porttitor eleifend feugiat.\n\nDonec scelerisque commodo tortor, sit amet mattis sapien dictum vel. Sed non efficitur lorem, vel mattis erat. Praesent et odio et purus faucibus tempus ac eu mi. Pellentesque euismod in lacus ac volutpat. Pellentesque vel ex nec tortor vestibulum porta. Nullam in lacus posuere enim imperdiet maximus. In id risus est.\n\nMorbi nec vestibulum diam, quis efficitur quam. Etiam eget gravida augue. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nisi lacus, volutpat quis dictum nec, laoreet et orci. Suspendisse iaculis et erat sit amet imperdiet. Nulla faucibus nunc nec tortor auctor, ac consequat justo tristique. Morbi sit amet dui quis purus ultricies luctus quis a orci.\n",
          "html": "<p>Ligula sit amet elementum mollis, neque odio eleifend lacus, non laoreet arcu risus id nibh. Cras vel nulla id arcu ullamcorper sodales sed sit amet lorem. Praesent pharetra, lectus eget rutrum cursus, orci metus cursus erat, a rhoncus ex velit ut purus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Ut in ipsum hendrerit, bibendum nibh ac, bibendum metus. Aenean volutpat est lectus, scelerisque congue risus fermentum ut. Pellentesque rutrum tempor ex, et accumsan enim. Maecenas a sem luctus, placerat diam eget, tempus quam. Fusce congue quam at vehicula efficitur. Vivamus gravida felis non nunc vulputate, laoreet aliquam sapien venenatis. Aenean viverra sapien ut orci lacinia vestibulum. Mauris at gravida tortor, non eleifend libero. In ut ipsum lacus. Proin risus velit, ornare et pulvinar at, sodales eget quam. Donec interdum in nulla nec dapibus.</p>\n<p>Curabitur scelerisque blandit placerat. Duis consequat tincidunt tortor, nec euismod ante ultrices et. Ut imperdiet, metus et fermentum blandit, mi elit scelerisque nunc, id porttitor justo ligula in lorem. Ut et ipsum tellus. Sed feugiat dolor sed accumsan bibendum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris lorem purus, mollis ut lobortis at, sodales ac justo.</p>\n<p>Duis turpis eros, lobortis eu feugiat a, mattis dapibus diam. Nulla at quam eros. Pellentesque consectetur varius tellus non sagittis. Aliquam erat volutpat. Pellentesque sed ante ac velit tempus hendrerit. Fusce sit amet eros a turpis dictum pharetra. Duis vulputate ultricies orci, nec pharetra dui dictum non. Proin convallis, justo vel malesuada molestie, mauris orci tincidunt diam, ultrices volutpat mi orci in augue. Nullam lorem erat, cursus a pellentesque nec, porta sit amet tellus. Donec porttitor eleifend feugiat.</p>\n<p>Donec scelerisque commodo tortor, sit amet mattis sapien dictum vel. Sed non efficitur lorem, vel mattis erat. Praesent et odio et purus faucibus tempus ac eu mi. Pellentesque euismod in lacus ac volutpat. Pellentesque vel ex nec tortor vestibulum porta. Nullam in lacus posuere enim imperdiet maximus. In id risus est.</p>\n<p>Morbi nec vestibulum diam, quis efficitur quam. Etiam eget gravida augue. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nisi lacus, volutpat quis dictum nec, laoreet et orci. Suspendisse iaculis et erat sit amet imperdiet. Nulla faucibus nunc nec tortor auctor, ac consequat justo tristique. Morbi sit amet dui quis purus ultricies luctus quis a orci.</p>"
        },
        "_id": "articles/dayjs-with-relative-time-nuxtjs.mdx",
        "_raw": {
          "sourceFilePath": "articles/dayjs-with-relative-time-nuxtjs.mdx",
          "sourceFileName": "dayjs-with-relative-time-nuxtjs.mdx",
          "sourceFileDir": "articles",
          "contentType": "mdx",
          "flattenedPath": "articles/dayjs-with-relative-time-nuxtjs"
        },
        "type": "Article",
        "readingTime": {
          "text": "2 min read",
          "minutes": 1.96,
          "time": 117600,
          "words": 392
        },
        "wordCount": 394,
        "slug": "dayjs-with-relative-time-nuxtjs"
      },
      "documentHash": "1673617146813",
      "hasWarnings": false,
      "documentTypeName": "Article"
    },
    "articles/nextjs-contentlayer-static-blog-guide.mdx": {
      "document": {
        "title": "Next.js and Contentlayer static blog guide",
        "publishedAt": "2022-09-02",
        "tags": [
          "nextjs",
          "react"
        ],
        "image": "/public/post-1-hero.webp",
        "body": {
          "raw": "\nIn this post, I'm going to build a blog demo app using Next.js and the blog will be powered by [Contentlayer](https://www.contentlayer.dev/).\n\nWe'll be making a statically generated, fast and simple blog with no need for a backend.\n\n[Contentlayer](https://www.contentlayer.dev/) will power the blog functionality using markdown files that we can commit to our repo.\n\nLet's get started.\n\nFirst, lets create a new Next.js application, you can follow the official guide [here](https://nextjs.org/docs). I will be using `yarn` for this, but you can use `npm` or `pnpm` also.\n\n```bash\nyarn create next-app\n```\n\nYou will be presented with some options if you use the above command, like the application name.\n\nOnce that has ran, you should navigate into that folder you just created.\n\n## Installing Contentlayer\n\nHead over to the [official docs](https://www.contentlayer.dev/) if you want to read more about Contentlayer.\n\nAdd Contentlayer\n\n```bash\nyarn add contentlayer next-contentlayer\n```\n\nOnce that has done, open your code in an IDE and open the `next.config.js` file, it should look like this.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n};\n\nmodule.exports = nextConfig;\n```\n\nChange it to add the `withContentlayer` import\n\n```js\nconst { withContentlayer } = require(\"next-contentlayer\");\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n};\n\nmodule.exports = withContentlayer(nextConfig);\n```\n\nWith that out the way, we need to create a new file at the root of our project called `jsconfig.json` or `tsconfig.json` if using TypeScript.\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/components/*\": [\"components/*\"],\n      \"contentlayer/generated\": [\"./.contentlayer/generated\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.jsx\", \"**/*.js\", \".contentlayer/generated\"]\n}\n```\n\nNext we're going to want to create a contentlayer config file in the root of our project called `contentlayer.config.js`\n\nThis is what I have in mine\n\n```js\nimport { defineDocumentType, makeSource } from \"contentlayer/source-files\";\n\nconst computedFields = {\n  slug: {\n    type: \"string\",\n    resolve: (doc) => doc._raw.sourceFileName.replace(/\\.md$/, \"\"),\n  },\n};\n\nexport const Post = defineDocumentType(() => ({\n  name: \"Post\",\n  filePathPattern: `posts/*.md`,\n  fields: {\n    title: { type: \"string\", required: true },\n    publishedAt: { type: \"string\", required: true },\n    tags: { type: \"string\" },\n    image: { type: \"string\" },\n  },\n  wordCount: {\n    type: \"number\",\n    resolve: (doc) => doc.body.raw.split(/\\s+/gu).length,\n  },\n  computedFields,\n}));\n\nexport default makeSource({\n  contentDirPath: \"data\",\n  documentTypes: [Post],\n});\n```\n\nWhat this is doing is specifying a single document type called `Post` and they're all going to live inside a folder called `data/posts/*.md`.\n\nYou can read more about how this works [here](https://www.contentlayer.dev/docs/getting-started).\n\nWe're going to create two new folders, in the root of our project, create a folder called `data`, then inside that, create another called `posts`. The reason we're nesting it like this, is once you get your head around Contentlayer, you can extend the config above to define different document types, for instance, you might want to have `Posts`, `Projects` and `Guides` all stored inside your code.\n\nInside the `data/posts` folder, create some markdown files that have the following format:\n\n```md\n---\ntitle: Lorem Ipsum\npublishedAt: 2022-06-24\ntags: ['Nextjs', 'React'] // optional\nimage: '/static/post-1-hero.webp' // optional\n---\n\nMollit nisi cillum exercitation minim officia velit laborum non Lorem\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\nlabore exercitation irure laborum.\n```\n\nThe title and publishedAt are required, but the tags and image are not, they're optional, (we specified this in the config above) so try and create some posts with and without the optional fields.\n\nThe folder structure should be the following:\n\n```\ndocs/\n├─ posts/\n│  ├─ post-1.md\n│  ├─ post-2.md\n│  ├─ post-3.md\n```\n\nYou are free to call these markdown files whatever you want, keep them lower-case and hyphenated as this will be the slug/url for that post.\n\nBefore we go any further, lets test that contentlayer is all hooked up correctly.\n\n```\nyarn dev\n```\n\nIf all works, you should get an output a bit like the following:\n\n```\n$ next dev\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\ninfo  - SWC minify release candidate enabled. https://nextjs.link/swcmin\nGenerated 3 documents in .contentlayer\nevent - compiled client and server successfully in 1225 ms (178 modules)\nwait  - compiling...\nevent - compiled client and server successfully in 49 ms (178 modules)\n```\n\nNotice the `Generated 3 documents in .contentlayer` bit, that tells us that we've hooked contentlayer up and its generated 3 files based on our markdown files.\n\nIf we look in our project, a `.contentlayer` folder has been created, don't edit anything inside of here as it gets regenerated each time things are changed. But if we go take a look, we should have a folder inside called `generated` and a `Post` folder inside that.\n\n```\n.\n└── .contentlayer/\n    ├── .cache\n    └── generated/\n        └── Post/\n            ├── _index.json\n            ├── _index.mjs\n            ├── posts__post-1.md.json\n            ├── posts__post-2.md.json\n            └── posts__post-3.md.json\n```\n\nTake a look at one of the files, `posts__post-1.md.json` and it will look something like this:\n\n```\n{\n  \"title\": \"My first blog post\",\n  \"publishedAt\": \"2022-06-24T00:00:00.000Z\",\n  \"tags\": [\n    \"Nextjs\",\n    \"React\"\n  ],\n  \"image\": \"/static/post-1-hero.webp\",\n  \"body\": {\n    \"raw\": \"\\nMollit nisi cillum exercitation minim officia velit laborum non Lorem\\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\\nlabore exercitation irure laborum.\\n\",\n    \"html\": \"<p>Mollit nisi cillum exercitation minim officia velit laborum non Lorem\\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\\nlabore exercitation irure laborum.</p>\"\n  },\n  \"_id\": \"posts/post-1.md\",\n  \"_raw\": {\n    \"sourceFilePath\": \"posts/post-1.md\",\n    \"sourceFileName\": \"post-1.md\",\n    \"sourceFileDir\": \"posts\",\n    \"contentType\": \"markdown\",\n    \"flattenedPath\": \"posts/post-1\"\n  },\n  \"type\": \"Post\",\n  \"slug\": \"post-1\"\n}\n```\n\nIn this file, we can see what contentlayer has generated, we've got `body.html` from our Markdown content, our slug, tags, date and title all there. Now lets use that inside react!\n\n## Rendering the posts\n\nWe're going to keep this simple by just using the `index.js` page to fetch our content, but we could if we wanted to, break this out into a separate page.\n\nOpen up the `pages/index.js` file and delete everything inside of it, we're going to start fresh.\n\nI'm a big fan of arrow functions but if you want to use a traditional function, that's fine.\n\nPlace this inside the `inedx.js` file to get started.\n\n```jsx\nconst Index = () => {\n  return <div>Hello world.</div>;\n};\n\nexport default Index;\n```\n\nIf you run the app with `yarn dev` now, and open it in a browser, `http://localhost:3000`, you should see a blank page with `hello world` in the corner. If so, great! Let's move on.\n\nNow update your index.js file to have the following:\n\n```jsx\nimport { allPosts } from \"contentlayer/generated\";\n\nexport async function getStaticProps() {\n  const posts = allPosts.sort(\n    (a, b) => Number(new Date(b.publishedAt)) - Number(new Date(a.publishedAt))\n  );\n  return { props: { posts } };\n}\n\nconst Index = ({ posts }) => {\n  console.log(posts);\n  return <div>Hello world!</div>;\n};\n\nexport default Index;\n```\n\nWhat we're doing here is adding the `allPosts` import that contentlayer generated, remember the `.contentlayer` folder, take a look in there at the `_index.mjs` file, that's where the `allPosts` function comes from.\n\nWe're going to use Next.js `getStaticProps` method (which is asynchronous) - `getStaticProps` is a method to tell Next.js to pre-render this page at build time, and use the props provided by `getStaticProps`. You can read more about this [here](https://nextjs.org/docs/basic-features/data-fetching/get-static-props).\n\nWe're then passing `posts` to the `Index` method, and if you `console.log(posts)` inside that, you'll be able to see them on the running app console.\n\nI also created a folder at the root of my project called `static` with some images inside `post-1-hero.webp` which is what is in the markdown file for the `image` tag.\n\nThis is my final `index.js` file\n\n```jsx\nimport { allPosts } from \"contentlayer/generated\";\nimport Image from \"next/image\";\n\nexport async function getStaticProps() {\n  const posts = allPosts.sort(\n    (a, b) => Number(new Date(b.publishedAt)) - Number(new Date(a.publishedAt))\n  );\n  return { props: { posts } };\n}\n\nconst Index = ({ posts }) => {\n  return (\n    <div>\n      <div className=\"posts\">\n        <h1>Posts</h1>\n\n        {posts.map((post, i) => (\n          <div key={i} className=\"post\">\n            <div>\n              <h2>{post.title}</h2>\n\n              <span>{post.publishedAt}</span>\n\n              {/* Loop through any tags if we have any */}\n              <ul>\n                {post.tags && post.tags.map((tag, i) => <li key={i}>{tag}</li>)}\n              </ul>\n            </div>\n\n            {post.image && (\n              <div\n                style={{\n                  width: \"200px\",\n                  position: \"relative\",\n                  height: \"100px\",\n                }}\n              >\n                <Image\n                  src={post.image}\n                  alt={post.title}\n                  layout=\"fill\"\n                  objectFit=\"cover\"\n                />\n              </div>\n            )}\n\n            {/* Post body */}\n            <p>{post.body.raw}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default Index;\n```\n\nIf you've followed this guide, you should be able to start your project\n\n```\nyarn dev\n```\n\nand see some `posts` on the page.\n\nThis will all be statically generated at build time which is great for speed, no need for a back-end to store your blog posts any more, just add a new post markdown file, commit it, and run a build/deploy.\n\nWhilst there are so many things that can be done with Contentlayer, you can look at adding pagination, fetching next and previous posts and having multiple document types, all within the same code-base.\n\nI really like contentlayer and the fact that it means I can write blog posts/article and just store them in my Git repo, posts can then be version controlled and I don't have the overhead of running a server to store the posts.\n\nFeel free to checkout this code in my repo [here](https://github.com/lordkerwin/nextjs-contentlayer-demo).\n\nI also use Contentlayer on my personal website, you can see the code for that [here](https://github.com/lordkerwin/v2) or see it in action by going to [seankerwin.dev](https://seankerwin.dev)\n",
          "html": "<p>In this post, I'm going to build a blog demo app using Next.js and the blog will be powered by <a href=\"https://www.contentlayer.dev/\">Contentlayer</a>.</p>\n<p>We'll be making a statically generated, fast and simple blog with no need for a backend.</p>\n<p><a href=\"https://www.contentlayer.dev/\">Contentlayer</a> will power the blog functionality using markdown files that we can commit to our repo.</p>\n<p>Let's get started.</p>\n<p>First, lets create a new Next.js application, you can follow the official guide <a href=\"https://nextjs.org/docs\">here</a>. I will be using <code>yarn</code> for this, but you can use <code>npm</code> or <code>pnpm</code> also.</p>\n<pre><code class=\"language-bash\">yarn create next-app\n</code></pre>\n<p>You will be presented with some options if you use the above command, like the application name.</p>\n<p>Once that has ran, you should navigate into that folder you just created.</p>\n<h2>Installing Contentlayer</h2>\n<p>Head over to the <a href=\"https://www.contentlayer.dev/\">official docs</a> if you want to read more about Contentlayer.</p>\n<p>Add Contentlayer</p>\n<pre><code class=\"language-bash\">yarn add contentlayer next-contentlayer\n</code></pre>\n<p>Once that has done, open your code in an IDE and open the <code>next.config.js</code> file, it should look like this.</p>\n<pre><code class=\"language-js\">/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n};\n\nmodule.exports = nextConfig;\n</code></pre>\n<p>Change it to add the <code>withContentlayer</code> import</p>\n<pre><code class=\"language-js\">const { withContentlayer } = require(\"next-contentlayer\");\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n};\n\nmodule.exports = withContentlayer(nextConfig);\n</code></pre>\n<p>With that out the way, we need to create a new file at the root of our project called <code>jsconfig.json</code> or <code>tsconfig.json</code> if using TypeScript.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/components/*\": [\"components/*\"],\n      \"contentlayer/generated\": [\"./.contentlayer/generated\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.jsx\", \"**/*.js\", \".contentlayer/generated\"]\n}\n</code></pre>\n<p>Next we're going to want to create a contentlayer config file in the root of our project called <code>contentlayer.config.js</code></p>\n<p>This is what I have in mine</p>\n<pre><code class=\"language-js\">import { defineDocumentType, makeSource } from \"contentlayer/source-files\";\n\nconst computedFields = {\n  slug: {\n    type: \"string\",\n    resolve: (doc) => doc._raw.sourceFileName.replace(/\\.md$/, \"\"),\n  },\n};\n\nexport const Post = defineDocumentType(() => ({\n  name: \"Post\",\n  filePathPattern: `posts/*.md`,\n  fields: {\n    title: { type: \"string\", required: true },\n    publishedAt: { type: \"string\", required: true },\n    tags: { type: \"string\" },\n    image: { type: \"string\" },\n  },\n  wordCount: {\n    type: \"number\",\n    resolve: (doc) => doc.body.raw.split(/\\s+/gu).length,\n  },\n  computedFields,\n}));\n\nexport default makeSource({\n  contentDirPath: \"data\",\n  documentTypes: [Post],\n});\n</code></pre>\n<p>What this is doing is specifying a single document type called <code>Post</code> and they're all going to live inside a folder called <code>data/posts/*.md</code>.</p>\n<p>You can read more about how this works <a href=\"https://www.contentlayer.dev/docs/getting-started\">here</a>.</p>\n<p>We're going to create two new folders, in the root of our project, create a folder called <code>data</code>, then inside that, create another called <code>posts</code>. The reason we're nesting it like this, is once you get your head around Contentlayer, you can extend the config above to define different document types, for instance, you might want to have <code>Posts</code>, <code>Projects</code> and <code>Guides</code> all stored inside your code.</p>\n<p>Inside the <code>data/posts</code> folder, create some markdown files that have the following format:</p>\n<pre><code class=\"language-md\">---\ntitle: Lorem Ipsum\npublishedAt: 2022-06-24\ntags: ['Nextjs', 'React'] // optional\nimage: '/static/post-1-hero.webp' // optional\n---\n\nMollit nisi cillum exercitation minim officia velit laborum non Lorem\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\nlabore exercitation irure laborum.\n</code></pre>\n<p>The title and publishedAt are required, but the tags and image are not, they're optional, (we specified this in the config above) so try and create some posts with and without the optional fields.</p>\n<p>The folder structure should be the following:</p>\n<pre><code>docs/\n├─ posts/\n│  ├─ post-1.md\n│  ├─ post-2.md\n│  ├─ post-3.md\n</code></pre>\n<p>You are free to call these markdown files whatever you want, keep them lower-case and hyphenated as this will be the slug/url for that post.</p>\n<p>Before we go any further, lets test that contentlayer is all hooked up correctly.</p>\n<pre><code>yarn dev\n</code></pre>\n<p>If all works, you should get an output a bit like the following:</p>\n<pre><code>$ next dev\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\ninfo  - SWC minify release candidate enabled. https://nextjs.link/swcmin\nGenerated 3 documents in .contentlayer\nevent - compiled client and server successfully in 1225 ms (178 modules)\nwait  - compiling...\nevent - compiled client and server successfully in 49 ms (178 modules)\n</code></pre>\n<p>Notice the <code>Generated 3 documents in .contentlayer</code> bit, that tells us that we've hooked contentlayer up and its generated 3 files based on our markdown files.</p>\n<p>If we look in our project, a <code>.contentlayer</code> folder has been created, don't edit anything inside of here as it gets regenerated each time things are changed. But if we go take a look, we should have a folder inside called <code>generated</code> and a <code>Post</code> folder inside that.</p>\n<pre><code>.\n└── .contentlayer/\n    ├── .cache\n    └── generated/\n        └── Post/\n            ├── _index.json\n            ├── _index.mjs\n            ├── posts__post-1.md.json\n            ├── posts__post-2.md.json\n            └── posts__post-3.md.json\n</code></pre>\n<p>Take a look at one of the files, <code>posts__post-1.md.json</code> and it will look something like this:</p>\n<pre><code>{\n  \"title\": \"My first blog post\",\n  \"publishedAt\": \"2022-06-24T00:00:00.000Z\",\n  \"tags\": [\n    \"Nextjs\",\n    \"React\"\n  ],\n  \"image\": \"/static/post-1-hero.webp\",\n  \"body\": {\n    \"raw\": \"\\nMollit nisi cillum exercitation minim officia velit laborum non Lorem\\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\\nlabore exercitation irure laborum.\\n\",\n    \"html\": \"&#x3C;p>Mollit nisi cillum exercitation minim officia velit laborum non Lorem\\nadipisicing dolore. Labore commodo consectetur commodo velit adipisicing irure\\ndolore dolor reprehenderit aliquip. Reprehenderit cillum mollit eiusmod\\nexcepteur elit ipsum aute pariatur in. Cupidatat ex culpa velit culpa ad non\\nlabore exercitation irure laborum.&#x3C;/p>\"\n  },\n  \"_id\": \"posts/post-1.md\",\n  \"_raw\": {\n    \"sourceFilePath\": \"posts/post-1.md\",\n    \"sourceFileName\": \"post-1.md\",\n    \"sourceFileDir\": \"posts\",\n    \"contentType\": \"markdown\",\n    \"flattenedPath\": \"posts/post-1\"\n  },\n  \"type\": \"Post\",\n  \"slug\": \"post-1\"\n}\n</code></pre>\n<p>In this file, we can see what contentlayer has generated, we've got <code>body.html</code> from our Markdown content, our slug, tags, date and title all there. Now lets use that inside react!</p>\n<h2>Rendering the posts</h2>\n<p>We're going to keep this simple by just using the <code>index.js</code> page to fetch our content, but we could if we wanted to, break this out into a separate page.</p>\n<p>Open up the <code>pages/index.js</code> file and delete everything inside of it, we're going to start fresh.</p>\n<p>I'm a big fan of arrow functions but if you want to use a traditional function, that's fine.</p>\n<p>Place this inside the <code>inedx.js</code> file to get started.</p>\n<pre><code class=\"language-jsx\">const Index = () => {\n  return &#x3C;div>Hello world.&#x3C;/div>;\n};\n\nexport default Index;\n</code></pre>\n<p>If you run the app with <code>yarn dev</code> now, and open it in a browser, <code>http://localhost:3000</code>, you should see a blank page with <code>hello world</code> in the corner. If so, great! Let's move on.</p>\n<p>Now update your index.js file to have the following:</p>\n<pre><code class=\"language-jsx\">import { allPosts } from \"contentlayer/generated\";\n\nexport async function getStaticProps() {\n  const posts = allPosts.sort(\n    (a, b) => Number(new Date(b.publishedAt)) - Number(new Date(a.publishedAt))\n  );\n  return { props: { posts } };\n}\n\nconst Index = ({ posts }) => {\n  console.log(posts);\n  return &#x3C;div>Hello world!&#x3C;/div>;\n};\n\nexport default Index;\n</code></pre>\n<p>What we're doing here is adding the <code>allPosts</code> import that contentlayer generated, remember the <code>.contentlayer</code> folder, take a look in there at the <code>_index.mjs</code> file, that's where the <code>allPosts</code> function comes from.</p>\n<p>We're going to use Next.js <code>getStaticProps</code> method (which is asynchronous) - <code>getStaticProps</code> is a method to tell Next.js to pre-render this page at build time, and use the props provided by <code>getStaticProps</code>. You can read more about this <a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-static-props\">here</a>.</p>\n<p>We're then passing <code>posts</code> to the <code>Index</code> method, and if you <code>console.log(posts)</code> inside that, you'll be able to see them on the running app console.</p>\n<p>I also created a folder at the root of my project called <code>static</code> with some images inside <code>post-1-hero.webp</code> which is what is in the markdown file for the <code>image</code> tag.</p>\n<p>This is my final <code>index.js</code> file</p>\n<pre><code class=\"language-jsx\">import { allPosts } from \"contentlayer/generated\";\nimport Image from \"next/image\";\n\nexport async function getStaticProps() {\n  const posts = allPosts.sort(\n    (a, b) => Number(new Date(b.publishedAt)) - Number(new Date(a.publishedAt))\n  );\n  return { props: { posts } };\n}\n\nconst Index = ({ posts }) => {\n  return (\n    &#x3C;div>\n      &#x3C;div className=\"posts\">\n        &#x3C;h1>Posts&#x3C;/h1>\n\n        {posts.map((post, i) => (\n          &#x3C;div key={i} className=\"post\">\n            &#x3C;div>\n              &#x3C;h2>{post.title}&#x3C;/h2>\n\n              &#x3C;span>{post.publishedAt}&#x3C;/span>\n\n              {/* Loop through any tags if we have any */}\n              &#x3C;ul>\n                {post.tags &#x26;&#x26; post.tags.map((tag, i) => &#x3C;li key={i}>{tag}&#x3C;/li>)}\n              &#x3C;/ul>\n            &#x3C;/div>\n\n            {post.image &#x26;&#x26; (\n              &#x3C;div\n                style={{\n                  width: \"200px\",\n                  position: \"relative\",\n                  height: \"100px\",\n                }}\n              >\n                &#x3C;Image\n                  src={post.image}\n                  alt={post.title}\n                  layout=\"fill\"\n                  objectFit=\"cover\"\n                />\n              &#x3C;/div>\n            )}\n\n            {/* Post body */}\n            &#x3C;p>{post.body.raw}&#x3C;/p>\n          &#x3C;/div>\n        ))}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n};\n\nexport default Index;\n</code></pre>\n<p>If you've followed this guide, you should be able to start your project</p>\n<pre><code>yarn dev\n</code></pre>\n<p>and see some <code>posts</code> on the page.</p>\n<p>This will all be statically generated at build time which is great for speed, no need for a back-end to store your blog posts any more, just add a new post markdown file, commit it, and run a build/deploy.</p>\n<p>Whilst there are so many things that can be done with Contentlayer, you can look at adding pagination, fetching next and previous posts and having multiple document types, all within the same code-base.</p>\n<p>I really like contentlayer and the fact that it means I can write blog posts/article and just store them in my Git repo, posts can then be version controlled and I don't have the overhead of running a server to store the posts.</p>\n<p>Feel free to checkout this code in my repo <a href=\"https://github.com/lordkerwin/nextjs-contentlayer-demo\">here</a>.</p>\n<p>I also use Contentlayer on my personal website, you can see the code for that <a href=\"https://github.com/lordkerwin/v2\">here</a> or see it in action by going to <a href=\"https://seankerwin.dev\">seankerwin.dev</a></p>"
        },
        "_id": "articles/nextjs-contentlayer-static-blog-guide.mdx",
        "_raw": {
          "sourceFilePath": "articles/nextjs-contentlayer-static-blog-guide.mdx",
          "sourceFileName": "nextjs-contentlayer-static-blog-guide.mdx",
          "sourceFileDir": "articles",
          "contentType": "mdx",
          "flattenedPath": "articles/nextjs-contentlayer-static-blog-guide"
        },
        "type": "Article",
        "readingTime": {
          "text": "8 min read",
          "minutes": 7.885,
          "time": 473100,
          "words": 1577
        },
        "wordCount": 1579,
        "slug": "nextjs-contentlayer-static-blog-guide"
      },
      "documentHash": "1673616636830",
      "hasWarnings": false,
      "documentTypeName": "Article"
    },
    "articles/popos-the-first-week.mdx": {
      "document": {
        "title": "Pop!_OS - The first week!",
        "publishedAt": "2022-06-26",
        "tags": [
          "linux",
          "popos"
        ],
        "image": "/public/post-1-hero.webp",
        "body": {
          "raw": "\nSo, I'm an avid Apple Mac user, and I've used macOS as my primary dev environment for over 10 years.\n\nThis has been mostly down to that my employer provided me with a top end Macbook Pro, so I have done everything within the apple ecosystem.\n\nMy current employer, the boss was pretty cool, I could set my mac's up how I wanted, have personal emails/icloud on it, use it for personal stuff and side-work (out of work hours ofcourse), So I've had no real reason to switch.\n\nI have just taken a new job, and decided that I want my own machine, keep work and personal stuff separated.\n\nDell were doing an amazing deal on their outlet website for the XPS range of laptops, and I managed to pickup a brand-new XPS 13 9305 with 16GB Ram, and i7 Quad Core, with 512GB M2 SSD, for £800.\n\nThe only problem is that it came with Windows 10 Home edition. I tried to use Windows with WSL2, but felt like it was a fight to get even the basics to work. Windows lasted less than a day on the laptop before I decided to install Linux.\n\nI've used Mint/Ubuntu before, and I know of System76 (who make awesome Linux machines by the way!) System76 also have developed Pop!\\_OS, a Ubuntu/Debian based OS that is, well, fucking amazing!\n\nIt's aimed at developers and is built from the ground up with that in mind. The keyboard shortcuts for multi-tasking is outstanding. I love the tile-view that comes and the global launcher/search makes me feel right at home, just like macOS and its Spotlight.\n\nNow, for installing it on the XPS, it was a simple case of heading over to the Pop!\\_OS website and grabbing the correct ISO that you need.\n\nI grabbed the 21.04 Non Nvidia version (as my laptop just has the Intel Iris XE graphics). Create a bootable USB and installed it on the XPS.\n\nAside from turning safe-boot off in the BIOS of the XPS, I did nothing else. Followed the on-screen instructions when installing the OS, I wiped my SSD and only have PopOS! as my main operating system.\n\nOnce it was installed, I opened the Pop!\\_Shop to let it check for updates and install them.\n\nSo far, I've been running PopOS! for over a week, and haven't had a single issue.\n\nI have the XPS plugged via USB-C to DisplayPort for a Iiyama 34\" Ultrawide running at 144hz, and a Seagate Barracuda Gaming Dock via Thunderbolt (Which has a 4TB Spinning drive and a 512GB M2-SSD inside it) and everything is working perfectly.\n\nI have things like Docker, PHP, Node, Jetbrains (WebStorm, PhpStorm and DataGrip), Visual Studio Code, Mailspring (For emails) and it even plays nicely with my Corsair Virtuso Headset.\n\nI could seriously see Pop!\\_OS replacing my Mac as a daily driver.\n\nI've never had such a great experience with a Linux distro before.\n\nYou can checkout Pop!\\_OS here.\nhttps://pop.system76.com\n",
          "html": "<p>So, I'm an avid Apple Mac user, and I've used macOS as my primary dev environment for over 10 years.</p>\n<p>This has been mostly down to that my employer provided me with a top end Macbook Pro, so I have done everything within the apple ecosystem.</p>\n<p>My current employer, the boss was pretty cool, I could set my mac's up how I wanted, have personal emails/icloud on it, use it for personal stuff and side-work (out of work hours ofcourse), So I've had no real reason to switch.</p>\n<p>I have just taken a new job, and decided that I want my own machine, keep work and personal stuff separated.</p>\n<p>Dell were doing an amazing deal on their outlet website for the XPS range of laptops, and I managed to pickup a brand-new XPS 13 9305 with 16GB Ram, and i7 Quad Core, with 512GB M2 SSD, for £800.</p>\n<p>The only problem is that it came with Windows 10 Home edition. I tried to use Windows with WSL2, but felt like it was a fight to get even the basics to work. Windows lasted less than a day on the laptop before I decided to install Linux.</p>\n<p>I've used Mint/Ubuntu before, and I know of System76 (who make awesome Linux machines by the way!) System76 also have developed Pop!_OS, a Ubuntu/Debian based OS that is, well, fucking amazing!</p>\n<p>It's aimed at developers and is built from the ground up with that in mind. The keyboard shortcuts for multi-tasking is outstanding. I love the tile-view that comes and the global launcher/search makes me feel right at home, just like macOS and its Spotlight.</p>\n<p>Now, for installing it on the XPS, it was a simple case of heading over to the Pop!_OS website and grabbing the correct ISO that you need.</p>\n<p>I grabbed the 21.04 Non Nvidia version (as my laptop just has the Intel Iris XE graphics). Create a bootable USB and installed it on the XPS.</p>\n<p>Aside from turning safe-boot off in the BIOS of the XPS, I did nothing else. Followed the on-screen instructions when installing the OS, I wiped my SSD and only have PopOS! as my main operating system.</p>\n<p>Once it was installed, I opened the Pop!_Shop to let it check for updates and install them.</p>\n<p>So far, I've been running PopOS! for over a week, and haven't had a single issue.</p>\n<p>I have the XPS plugged via USB-C to DisplayPort for a Iiyama 34\" Ultrawide running at 144hz, and a Seagate Barracuda Gaming Dock via Thunderbolt (Which has a 4TB Spinning drive and a 512GB M2-SSD inside it) and everything is working perfectly.</p>\n<p>I have things like Docker, PHP, Node, Jetbrains (WebStorm, PhpStorm and DataGrip), Visual Studio Code, Mailspring (For emails) and it even plays nicely with my Corsair Virtuso Headset.</p>\n<p>I could seriously see Pop!_OS replacing my Mac as a daily driver.</p>\n<p>I've never had such a great experience with a Linux distro before.</p>\n<p>You can checkout Pop!_OS here.\nhttps://pop.system76.com</p>"
        },
        "_id": "articles/popos-the-first-week.mdx",
        "_raw": {
          "sourceFilePath": "articles/popos-the-first-week.mdx",
          "sourceFileName": "popos-the-first-week.mdx",
          "sourceFileDir": "articles",
          "contentType": "mdx",
          "flattenedPath": "articles/popos-the-first-week"
        },
        "type": "Article",
        "readingTime": {
          "text": "3 min read",
          "minutes": 2.47,
          "time": 148200,
          "words": 494
        },
        "wordCount": 496,
        "slug": "popos-the-first-week"
      },
      "documentHash": "1673616798002",
      "hasWarnings": false,
      "documentTypeName": "Article"
    }
  }
}
